<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>RobotController - –ê–≤—Ç–æ–Ω–æ–º–Ω–∏–π –Ω–∞–≤—ñ–≥–∞—Ü—ñ–π–Ω–∏–π —Ä–æ–±–æ—Ç</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f4f4f4;
        }
        h1, h2 {
            color: #333;
        }
        .code-section {
            background-color: #f1f1f1;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #e9e9e9;
            padding: 10px;
            border-radius: 5px;
        }
        .improvement {
            background-color: #e6f3ff;
            border-left: 4px solid #2196F3;
            padding: 10px;
            margin: 10px 0;
        }
        #full-code {
            max-height: 600px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>RobotController - –ê–≤—Ç–æ–Ω–æ–º–Ω–∏–π –Ω–∞–≤—ñ–≥–∞—Ü—ñ–π–Ω–∏–π —Ä–æ–±–æ—Ç</h1>

    <section>
        <h2>ü§ñ –û–≥–ª—è–¥ –ø—Ä–æ–µ–∫—Ç—É</h2>
        <p>–ü—Ä–æ–µ–∫—Ç —Å—Ç–≤–æ—Ä—é—î —ñ–Ω—Ç–µ–ª–µ–∫—Ç—É–∞–ª—å–Ω—É —Å–∏—Å—Ç–µ–º—É –∫–µ—Ä—É–≤–∞–Ω–Ω—è —Ä–æ–±–æ—Ç–æ–º –∑ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º –º–∞—à–∏–Ω–Ω–æ–≥–æ –Ω–∞–≤—á–∞–Ω–Ω—è —Ç–∞ Arduino.</p>
    </section>

    <section>
        <h2>üîß –ö–ª—é—á–æ–≤—ñ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏</h2>
        <div class="improvement">
            <h3>–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è ‚Ññ1: –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –≤–∏—è–≤–ª–µ–Ω–Ω—è –ø–æ—Ä—Ç—É Arduino</h3>
            <pre><code>
# –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –ø–æ—à—É–∫ –ø–æ—Ä—Ç—É Arduino
if port is None:
    ports = list(serial.tools.list_ports.comports())
    for p in ports:
        # –®—É–∫–∞—î–º–æ Arduino —Å–µ—Ä–µ–¥ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –ø–æ—Ä—Ç—ñ–≤
        if 'Arduino' in p.description or 'CH340' in p.description:
            port = p.device
            break
            </code></pre>
            <p>–°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å –ø–æ—Ä—Ç Arduino, —â–æ —Å–ø—Ä–æ—â—É—î –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è.</p>
        </div>

        <div class="improvement">
            <h3>–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è ‚Ññ2: –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Ç—Ä–µ–Ω—É–≤–∞–ª—å–Ω–∏—Ö –¥–∞–Ω–∏—Ö</h3>
            <pre><code>
def generate_comprehensive_training_data(self, num_samples=500):
    # –°–∏–º—É–ª—è—Ü—ñ—è —Å–µ–Ω—Å–æ—Ä–Ω–∏—Ö –¥–∞–Ω–∏—Ö –¥–ª—è –Ω–∞–≤—á–∞–Ω–Ω—è –º–æ–¥–µ–ª—ñ
    X = []  # –í—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ
    y = []  # –ú—ñ—Ç–∫–∏ –¥—ñ–π

    for _ in range(num_samples):
        # –°–∏–º—É–ª—è—Ü—ñ—è –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ —Ä—ñ–∑–Ω–∏—Ö —Å–µ–Ω—Å–æ—Ä—ñ–≤
        sensor_readings = [
            front_left, front_center, front_right,  # –§—Ä–æ–Ω—Ç–∞–ª—å–Ω—ñ —Å–µ–Ω—Å–æ—Ä–∏
            side_left, side_right,  # –ë–æ–∫–æ–≤—ñ —Å–µ–Ω—Å–æ—Ä–∏
            current_angle,  # –ü–æ—Ç–æ—á–Ω–∞ –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—è
            proximity_warning  # –ü–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –ø—Ä–æ –Ω–∞–±–ª–∏–∂–µ–Ω–Ω—è –ø–µ—Ä–µ—à–∫–æ–¥
        ]
        
        # –õ–æ–≥—ñ–∫–∞ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –¥—ñ–π —Ä–æ–±–æ—Ç–∞
        action = self.determine_action(sensor_readings)
        
        X.append(sensor_readings)
        y.append(action)
    
    return np.array(X), np.array(y)
            </code></pre>
            <p>–°—Ç–≤–æ—Ä–µ–Ω–æ —Å–∏—Å—Ç–µ–º—É –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó —Å–∏–Ω—Ç–µ—Ç–∏—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö –¥–ª—è –Ω–∞–≤—á–∞–Ω–Ω—è –º–æ–¥–µ–ª—ñ –∑ —Ä—ñ–∑–Ω–∏–º–∏ —Å—Ü–µ–Ω–∞—Ä—ñ—è–º–∏.</p>
        </div>

        <div class="improvement">
            <h3>–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è ‚Ññ3: –ú–∞—à–∏–Ω–Ω–µ –Ω–∞–≤—á–∞–Ω–Ω—è –¥–ª—è –Ω–∞–≤—ñ–≥–∞—Ü—ñ—ó</h3>
            <pre><code>
def train_navigation_model(self, custom_data_path=None):
    # –ì–Ω—É—á–∫–∏–π –≤–∏–±—ñ—Ä –¥–∂–µ—Ä–µ–ª–∞ –¥–∞–Ω–∏—Ö: 
    # 1. –í–ª–∞—Å–Ω—ñ –¥–∞–Ω—ñ –∑ CSV
    # 2. –ó–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω—ñ —Å–∏–º—É–ª—å–æ–≤–∞–Ω—ñ –¥–∞–Ω—ñ
    
    # –ù–∞–≤—á–∞–Ω–Ω—è –º–æ–¥–µ–ª—ñ –≤–∏–ø–∞–¥–∫–æ–≤–æ–≥–æ –ª—ñ—Å—É
    model = RandomForestClassifier(
        n_estimators=100,  # –ë—ñ–ª—å—à–µ –¥–µ—Ä–µ–≤ –¥–ª—è –∫—Ä–∞—â–æ—ó —É–∑–∞–≥–∞–ª—å–Ω–µ–Ω–æ—Å—Ç—ñ
        max_depth=10,      # –ì–ª–∏–±—à—ñ –¥–µ—Ä–µ–≤–∞ –¥–ª—è —Å–∫–ª–∞–¥–Ω–∏—Ö –ø–∞—Ç–µ—Ä–Ω—ñ–≤
        random_state=42
    )
    model.fit(x_train, y_train)
    
    return model
            </code></pre>
            <p>–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è RandomForest –¥–ª—è –ø—Ä–∏–π–Ω—è—Ç—Ç—è —Ä—ñ—à–µ–Ω—å –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–µ–Ω—Å–æ—Ä–Ω–∏—Ö –¥–∞–Ω–∏—Ö.</p>
        </div>
    </section>

    <section>
        <h2>üß† –õ–æ–≥—ñ–∫–∞ –Ω–∞–≤—ñ–≥–∞—Ü—ñ—ó</h2>
        <div class="code-section">
            <h3>–û—Å–Ω–æ–≤–Ω—ñ –¥—ñ—ó —Ä–æ–±–æ—Ç–∞:</h3>
            <ul>
                <li>–ó—É–ø–∏–Ω–∫–∞ –ø—Ä–∏ –±–ª–∏–∑—å–∫–∏—Ö –ø–µ—Ä–µ—à–∫–æ–¥–∞—Ö</li>
                <li>–†—É—Ö –≤–ø–µ—Ä–µ–¥ –∑–∞ –≤—ñ–¥—Å—É—Ç–Ω–æ—Å—Ç—ñ –ø–µ—Ä–µ—à–∫–æ–¥</li>
                <li>–ü–æ–≤–æ—Ä–æ—Ç –ª—ñ–≤–æ—Ä—É—á/–ø—Ä–∞–≤–æ—Ä—É—á –ø—Ä–∏ –≤–∏—è–≤–ª–µ–Ω–Ω—ñ –ø–µ—Ä–µ—à–∫–æ–¥</li>
            </ul>
        </div>
    </section>

    <section>
        <h2>üì¶ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω—ñ –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∏</h2>
        <ul>
            <li>NumPy: –ß–∏—Å–µ–ª—å–Ω—ñ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è</li>
            <li>Pandas: –†–æ–±–æ—Ç–∞ –∑ –¥–∞–Ω–∏–º–∏</li>
            <li>PyFirmata: –í–∑–∞—î–º–æ–¥—ñ—è –∑ Arduino</li>
            <li>Scikit-learn: –ú–∞—à–∏–Ω–Ω–µ –Ω–∞–≤—á–∞–Ω–Ω—è</li>
            <li>Serial: –ü–æ—Å–ª—ñ–¥–æ–≤–Ω–µ –∑'—î–¥–Ω–∞–Ω–Ω—è</li>
        </ul>
    </section>

    <section>
        <h2>üöß –û–±–º–µ–∂–µ–Ω–Ω—è —Ç–∞ –º–∞–π–±—É—Ç–Ω—ñ –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è</h2>
        <ul>
            <li>–î–æ–¥–∞—Ç–∏ –∫–∞–ª—ñ–±—Ä—É–≤–∞–Ω–Ω—è —Å–µ–Ω—Å–æ—Ä—ñ–≤</li>
            <li>–†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –±—ñ–ª—å—à —Å–∫–ª–∞–¥–Ω—ñ —Å—Ç—Ä–∞—Ç–µ–≥—ñ—ó —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø–µ—Ä–µ—à–∫–æ–¥</li>
            <li>–í–ø—Ä–æ–≤–∞–¥–∏—Ç–∏ –Ω–µ–ø–µ—Ä–µ—Ä–≤–Ω–µ –Ω–∞–≤—á–∞–Ω–Ω—è</li>
        </ul>
    </section>

    <section>
        <h2>üìÑ –ü–æ–≤–Ω–∏–π –∫–æ–¥ –ø—Ä–æ–µ–∫—Ç—É</h2>
        <div id="full-code" class="code-section">
            <pre><code>
import numpy as np
import pandas as pd
from pyfirmata import Arduino, util
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
import random
import time
import os
import serial.tools.list_ports

class RobotController:
    def __init__(self, port=None, baudrate=9600):
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –ø–æ—à—É–∫ –ø–æ—Ä—Ç—É Arduino
        if port is None:
            ports = list(serial.tools.list_ports.comports())
            for p in ports:
                # –®—É–∫–∞—î–º–æ Arduino —Å–µ—Ä–µ–¥ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –ø–æ—Ä—Ç—ñ–≤
                if 'Arduino' in p.description or 'CH340' in p.description:
                    port = p.device
                    break
            
        if port is None:
            available_ports = '\n'.join([p.device for p in ports])
            raise Exception(f"Arduino –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –î–æ—Å—Ç—É–ø–Ω—ñ –ø–æ—Ä—Ç–∏:\n{available_ports}")
            
        try:
            self.board = Arduino(port, baudrate=baudrate)
            print(f"–ü—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Arduino –Ω–∞ –ø–æ—Ä—Ç—É {port}")
        except serial.SerialException as e:
            raise Exception(f"–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –ø–æ—Ä—Ç—É {port}: {str(e)}")
            
        self.iterator = util.Iterator(self.board)
        self.iterator.start()
        
        # Pin configurations
        self.pins = {
            'left_forward': self.board.get_pin('d:8:o'),
            'left_backward': self.board.get_pin('d:9:o'),
            'right_forward': self.board.get_pin('d:10:o'),
            'right_backward': self.board.get_pin('d:11:o'),
            'servo1': self.board.get_pin('d:5:s'),  # Horizontal servo
            'servo2': self.board.get_pin('d:6:s'),  # Vertical servo
            'echo': self.board.get_pin('d:7:o')
        }
        
        # Movement speeds (0-1 range)
        self.speed = {
            'forward': 0.7,
            'backward': 0.7,
            'turn': 0.5
        }

    def ping(self, n=3):
        """Measure average distance using ultrasonic sensor."""
        return sum([util.ping_time_to_distance(self.pins['echo'].ping()) for _ in range(n)]) / n

    def move_forward(self, duration=1, speed=None):
        """Move robot forward with controllable speed and duration."""
        speed = speed if speed is not None else self.speed['forward']
        self.pins['right_forward'].write(speed)
        self.pins['left_forward'].write(speed)
        time.sleep(duration)
        self.stop()

    def move_backward(self, duration=1, speed=None):
        """Move robot backward with controllable speed and duration."""
        speed = speed if speed is not None else self.speed['backward']
        self.pins['right_backward'].write(speed)
        self.pins['left_backward'].write(speed)
        time.sleep(duration)
        self.stop()

    def turn_left(self, duration=0.5, speed=None):
        """Turn robot left."""
        speed = speed if speed is not None else self.speed['turn']
        self.pins['left_backward'].write(speed)
        self.pins['right_forward'].write(speed)
        time.sleep(duration)
        self.stop()

    def turn_right(self, duration=0.5, speed=None):
        """Turn robot right."""
        speed = speed if speed is not None else self.speed['turn']
        self.pins['right_backward'].write(speed)
        self.pins['left_forward'].write(speed)
        time.sleep(duration)
        self.stop()

    def stop(self):
        """Stop all motor movements."""
        for pin in ['left_forward', 'left_backward', 'right_forward', 'right_backward']:
            self.pins[pin].write(0)

    def generate_comprehensive_training_data(self, num_samples=500):
        """
        Generate comprehensive training data simulating various obstacle scenarios
        
        Actions:
        0: Stop (obstacle too close)
        1: Move forward
        2: Turn left
        3: Turn right
        
        Sensor inputs simulate:
        - Distance to obstacles
        - Angle of detection
        - Proximity warnings
        """
        np.random.seed(42)
        
        # Sensor features
        X = []
        # Corresponding actions
        y = []
        
        for _ in range(num_samples):
            # Simulate multiple sensor readings
            sensor_readings = []
            
            # Front distance sensors
            front_left = np.random.uniform(0, 100)
            front_center = np.random.uniform(0, 100)
            front_right = np.random.uniform(0, 100)
            
            # Side distance sensors
            side_left = np.random.uniform(0, 50)
            side_right = np.random.uniform(0, 50)
            
            # Angle and directional information
            current_angle = np.random.uniform(0, 180)
            
            # Combine all sensor readings
            sensor_readings = [
                front_left, front_center, front_right,  # Front sensors
                side_left, side_right,  # Side sensors
                current_angle,  # Current orientation
                1 if front_center < 20 else 0,  # Proximity warning
                1 if side_left < 10 else 0,  # Left side proximity
                1 if side_right < 10 else 0   # Right side proximity
            ]
            
            # Determine action based on sensor readings
            if front_center < 20:  # Close obstacle
                action = 0  # Stop
            elif front_left < 30 and front_right > 50:
                action = 2  # Turn left
            elif front_right < 30 and front_left > 50:
                action = 3  # Turn right
            else:
                action = 1  # Move forward
            
            X.append(sensor_readings)
            y.append(action)
        
        return np.array(X), np.array(y)

    def train_navigation_model(self, custom_data_path=None):
        """
        Train navigation model with comprehensive simulated data
        
        Args:
            custom_data_path (str, optional): Path to custom CSV training data
        
        Returns:
            Trained machine learning model
        """
        # Option to load custom data
        if custom_data_path and os.path.exists(custom_data_path):
            df = pd.read_csv(custom_data_path)
            X = df.drop('action', axis=1).values
            y = df['action'].values
        else:
            # Generate comprehensive simulated training data
            X, y = self.generate_comprehensive_training_data()
        
        # Split data
        x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
        
        # Train RandomForest model
        model = RandomForestClassifier(
            n_estimators=100,  # More trees for better generalization
            max_depth=10,      # Deeper trees to capture complex patterns
            random_state=42
        )
        model.fit(x_train, y_train)
        
        # Print model performance
        print("Training Data Shape:", X.shape)
        print("Model Accuracy:", model.score(x_test, y_test))
        
        return model

    def navigate(self, model):
        """
        Autonomous navigation using trained model
        
        Simulate navigation by processing sensor data and predicting actions
        """
        while True:
            # Simulate sensor data collection
            sensor_readings = []
            
            # Front distance sensors
            front_left = self.ping(3)  # Left side distance
            front_center = self.ping(3)  # Center distance
            front_right = self.ping(3)  # Right side distance
            
            # Side distance sensors (simulated)
            side_left = self.ping(3)
            side_right = self.ping(3)
            
            # Current angle (simulated)
            current_angle = np.random.uniform(0, 180)
            
            sensor_readings = [
                front_left, front_center, front_right,
                side_left, side_right,
                current_angle,
                1 if front_center < 20 else 0,
                1 if side_left < 10 else 0,
                1 if side_right < 10 else 0
            ]
            
            # Predict action
            action = model.predict([sensor_readings])[0]
            
            # Execute corresponding action
            if action == 0:
                self.stop()
            elif action == 1:
                self.move_forward(duration=0.5)
            elif action == 2:
                self.turn_left(duration=0.3)
            elif action == 3:
                self.turn_right(duration=0.3)
            
            # Short pause between